<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snowboard Trails</title>
  <link rel="stylesheet" href="styles/styles.css">
  <style>
    html, body { height: 100%; margin: 0; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow: hidden;
      background: radial-gradient(1200px 700px at 50% 10%, rgba(120,200,255,.25), transparent 60%),
                  radial-gradient(1200px 900px at 50% 110%, rgba(20,60,120,.25), transparent 60%),
                  #06121f;
      color: #eaf4ff;
    }

    .wrap{
      height: 100%;
      display: grid;
      place-items: center;
      padding: 18px;
    }

    .frame{
      width: min(980px, 96vw);
      aspect-ratio: 16 / 9;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 26px 80px rgba(0,0,0,.55);
      overflow: hidden;
      background: rgba(255,255,255,.04);
      position: relative;
    }

    canvas{
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    }

    .hud{
      position: absolute;
      inset: 14px 14px auto 14px;
      display: flex;
      gap: 10px;
      align-items: flex-start;
      justify-content: space-between;
      pointer-events: none;
    }

    .card{
      pointer-events: none;
      backdrop-filter: blur(10px);
      background: rgba(10, 20, 35, .55);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      line-height: 1.25;
    }

    .row{ display: flex; gap: 10px; flex-wrap: wrap; }
    .k{
      opacity:.85;
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
    }
    .v{
      font-weight: 700;
      font-size: 14px;
    }
    .big{
      font-size: 18px;
      font-weight: 800;
      letter-spacing: -0.02em;
    }

    .help{
      position: absolute;
      left: 14px;
      right: 14px;
      bottom: 14px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      pointer-events: none;
    }

    .pill{
      pointer-events: none;
      display: inline-flex;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(10, 20, 35, .55);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      font-size: 13px;
      color: rgba(234,244,255,.92);
      white-space: nowrap;
    }

    .overlay{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(800px 500px at 50% 40%, rgba(0,0,0,.55), rgba(0,0,0,.72));
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease;
    }
    .overlay.show{ opacity: 1; pointer-events: auto; }

    .modal{
      width: min(560px, 92vw);
      border-radius: 18px;
      padding: 18px 18px 16px;
      background: rgba(10, 20, 35, .70);
      border: 1px solid rgba(255,255,255,.16);
      box-shadow: 0 30px 100px rgba(0,0,0,.6);
    }
    .modal h1{
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing: -0.01em;
    }
    .modal p{
      margin: 0 0 10px;
      opacity: .9;
      font-size: 14px;
      line-height: 1.45;
    }
    .modal ul{
      margin: 0;
      padding-left: 18px;
      opacity: .95;
      font-size: 14px;
      line-height: 1.55;
    }
    .modal .cta{
      margin-top: 12px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      opacity: .95;
      font-size: 13px;
    }
    .key{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 28px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.07);
      font-weight: 800;
      letter-spacing: .02em;
    }

    .white{
        color: white;
    }
  </style>
</head>
<body>

    <a href="index.html" class="white">Back to Snowboarding Page</a>
  <div class="wrap">
    <div class="frame">
      <canvas id="c"></canvas>

      <div class="hud">
        <div class="card">
          <div class="big">Slopes</div>
          <div class="row" style="margin-top:8px;">
            <div>
              <div class="k">Level</div>
              <div class="v" id="hudLevel">1</div>
            </div>
            <div>
              <div class="k">Time</div>
              <div class="v" id="hudTime">0.00s</div>
            </div>
            <div>
              <div class="k">Best</div>
              <div class="v" id="hudBest">—</div>
            </div>
          </div>
        </div>

        <div class="card" style="text-align:right;">
          <div class="row" style="justify-content:flex-end;">
            <div>
              <div class="k">Speed</div>
              <div class="v" id="hudSpeed">0</div>
            </div>
            <div>
              <div class="k">Mistakes</div>
              <div class="v" id="hudMistakes">0 / 5</div>
            </div>
          </div>
          <div class="k" style="margin-top:8px; opacity:.75;">Avoid trees to stay fast</div>
        </div>
      </div>

      <div class="help">
        <div class="pill">⬅️ ➡️ steer • ⬆️ stabilize • ⬇️ carve (riskier)</div>
        <div class="pill">Press <span class="key">P</span> to pause • <span class="key">R</span> restart level</div>
      </div>

      <div class="overlay show" id="overlay">
        <div class="modal">
          <h1>How to play</h1>
          <p>You're snowboarding down a set of trails. The cleaner you ride, the faster you finish.</p>
          <ul>
            <li><b>Arrow keys</b>: steer left/right (you always move downhill)</li>
            <li>Hit trees = you slow down and gain a mistake</li>
            <li><b>5 mistakes</b> → restart the <b>same level</b></li>
            <li>Reach the finish line → next level gets tighter + curvier</li>
          </ul>
          <div class="cta">
            <div>Start / resume: <span class="key">Space</span></div>
            <div>Tip: stay near the center for max speed</div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const hudLevel = document.getElementById('hudLevel');
  const hudTime = document.getElementById('hudTime');
  const hudBest = document.getElementById('hudBest');
  const hudSpeed = document.getElementById('hudSpeed');
  const hudMistakes = document.getElementById('hudMistakes');
  const overlay = document.getElementById('overlay');

  // --- canvas sizing (HiDPI) ---
  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    W = rect.width;
    H = rect.height;
  }
  let W = 0, H = 0;
  window.addEventListener('resize', resize);
  resize();

  // --- input ---
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Space","KeyP","KeyR"].includes(e.code)) e.preventDefault();
    keys.add(e.code);

    if (e.code === "Space") {
      if (overlay.classList.contains('show')) overlay.classList.remove('show');
      paused = false;
    }
    if (e.code === "KeyP") paused = !paused;
    if (e.code === "KeyR") resetLevel(level);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));

  // --- game state ---
  let paused = true;
  let level = 1;
  let bestTimes = {}; // level -> seconds
  let timeStart = 0;
  let elapsed = 0;

  // Player in screen space
  const player = {
    x: 0, y: 0,
    vx: 0,  // side drift
    speed: 0, // downhill speed (world scroll speed)
    radius: 10,
    mistakes: 0,
    wobble: 0
  };

  // Trail is defined along "world y" and we scroll it toward the player
  // We'll represent trail center curve as segments.
  let segments = [];
  let trees = [];
  let finishY = 0;
  let worldY = 0; // how far we've gone down the level

  // Particles (snow)
  const flakes = [];
  function seedFlakes() {
    flakes.length = 0;
    for (let i=0;i<120;i++){
      flakes.push({
        x: Math.random()*W,
        y: Math.random()*H,
        r: 1 + Math.random()*2.2,
        vy: 18 + Math.random()*60,
        a: 0.25 + Math.random()*0.5
      });
    }
  }
  seedFlakes();

  // --- level generator ---
  function genLevel(lv){
    const segLen = 60;                // distance per segment (world units)
    const segCount = 60 + lv * 10;    // longer levels as it progresses
    const baseWidth = 420 - lv * 18;  // narrower each level
    const width = Math.max(240, baseWidth);

    const maxTurn = Math.min(220, 70 + lv * 14); // how curvy
    const rough = Math.min(1.2, 0.35 + lv * 0.05);

    segments = [];
    let cx = W/2;
    let target = cx;
    let phase = Math.random()*Math.PI*2;

    for (let i=0;i<segCount;i++){
      const y = i * segLen;
      // smooth turning target
      if (i % 6 === 0) {
        phase += 0.7 + Math.random()*0.6;
        target = W/2 + Math.sin(phase) * maxTurn;
      }
      cx += (target - cx) * (0.22 + rough*0.08);
      segments.push({
        y,
        cx,
        w: width - Math.min(width*0.30, lv*6) * (i/segCount) // subtle taper
      });
    }

    finishY = segments[segments.length - 1].y + segLen;

    // Place trees along edges with occasional “clusters”
    trees = [];
    const treeCount = 70 + lv * 18;
    for (let i=0;i<treeCount;i++){
      const ty = Math.random() * (finishY - 120) + 80;
      const {cx: tcx, w: tw} = sampleTrail(ty);
      const side = Math.random() < 0.5 ? -1 : 1;
      const edgeX = tcx + side*(tw/2);
      const pad = 18 + Math.random()*46;

      const cluster = Math.random() < (0.12 + lv*0.01);
      const extra = cluster ? (20 + Math.random()*60) : 0;

      trees.push({
        x: edgeX + side*(pad + extra),
        y: ty,
        r: 14 + Math.random()*10,
        hit: 0
      });
    }
  }

  function sampleTrail(y){
    // find surrounding segments and interpolate
    const segLen = 60;
    const i = Math.max(0, Math.min(segments.length-2, Math.floor(y/segLen)));
    const a = segments[i];
    const b = segments[i+1];
    const t = (y - a.y) / (b.y - a.y);
    return {
      cx: a.cx + (b.cx - a.cx)*t,
      w:  a.w  + (b.w  - a.w)*t
    };
  }

  function resetLevel(lv){
    level = lv;
    genLevel(level);

    worldY = 0;
    player.x = W/2;
    player.y = H*0.68;
    player.vx = 0;
    player.speed = 220 + level*14; // base downhill speed
    player.mistakes = 0;
    player.wobble = 0;

    elapsed = 0;
    timeStart = performance.now();
    paused = true;
    overlay.classList.add('show');
    updateHUD();
  }

  resetLevel(1);

  // --- collisions ---
  function circleHit(ax, ay, ar, bx, by, br){
    const dx = ax-bx, dy = ay-by;
    const d2 = dx*dx + dy*dy;
    const rr = (ar+br)*(ar+br);
    return d2 <= rr;
  }

  // --- HUD ---
  function fmtTime(s){
    return s.toFixed(2) + "s";
  }
  function updateHUD(){
    hudLevel.textContent = level;
    hudTime.textContent = fmtTime(elapsed);
    hudSpeed.textContent = Math.round(player.speed);
    hudMistakes.textContent = `${player.mistakes} / 5`;
    const best = bestTimes[level];
    hudBest.textContent = best ? fmtTime(best) : "—";
  }

  // --- rendering ---
  function drawBackground(){
    // subtle sky-to-snow gradient
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "rgba(180,235,255,0.16)");
    g.addColorStop(0.55, "rgba(255,255,255,0.06)");
    g.addColorStop(1, "rgba(255,255,255,0.03)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // snow particles
    for (const f of flakes){
      ctx.globalAlpha = f.a;
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawTrail(){
    // draw trail area + edges
    ctx.save();
    ctx.translate(0, 0);

    // create a path for the trail polygon based on visible range
    const topY = worldY - 120;
    const botY = worldY + (H - player.y) + 180;

    // sample a bunch of points
    const ptsL = [];
    const ptsR = [];
    const step = 22;

    for (let wy = topY; wy <= botY; wy += step){
      const {cx, w} = sampleTrail(Math.max(0, Math.min(finishY, wy)));
      const sy = player.y - (wy - worldY); // convert world y to screen y
      ptsL.push({ x: cx - w/2, y: sy });
      ptsR.push({ x: cx + w/2, y: sy });
    }

    // outside snow banks
    ctx.fillStyle = "rgba(255,255,255,0.07)";
    ctx.fillRect(0,0,W,H);

    // trail fill
    ctx.beginPath();
    ctx.moveTo(ptsL[0].x, ptsL[0].y);
    for (let i=1;i<ptsL.length;i++) ctx.lineTo(ptsL[i].x, ptsL[i].y);
    for (let i=ptsR.length-1;i>=0;i--) ctx.lineTo(ptsR[i].x, ptsR[i].y);
    ctx.closePath();

    const tg = ctx.createLinearGradient(0, 0, 0, H);
    tg.addColorStop(0, "rgba(255,255,255,0.18)");
    tg.addColorStop(1, "rgba(255,255,255,0.10)");
    ctx.fillStyle = tg;
    ctx.fill();

    // edges
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(210,245,255,0.22)";
    ctx.beginPath();
    ctx.moveTo(ptsL[0].x, ptsL[0].y);
    for (let i=1;i<ptsL.length;i++) ctx.lineTo(ptsL[i].x, ptsL[i].y);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(ptsR[0].x, ptsR[0].y);
    for (let i=1;i<ptsR.length;i++) ctx.lineTo(ptsR[i].x, ptsR[i].y);
    ctx.stroke();

    // finish line
    const finishScreenY = player.y - (finishY - worldY);
    if (finishScreenY > -40 && finishScreenY < H + 40){
      const {cx, w} = sampleTrail(finishY);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(cx - w/2, finishScreenY - 6, w, 12);
      ctx.fillStyle = "rgba(10,20,35,0.35)";
      for (let i=0;i<18;i++){
        const x = cx - w/2 + i*(w/18);
        ctx.fillRect(x, finishScreenY - 6, w/36, 12);
      }
    }

    ctx.restore();
  }

  function drawTrees(){
    // draw trees in view (world->screen)
    const viewTop = worldY - 160;
    const viewBottom = worldY + (H - player.y) + 220;

    for (const t of trees){
      if (t.y < viewTop || t.y > viewBottom) continue;
      const sy = player.y - (t.y - worldY);
      const x = t.x;

      // tree “shadow”
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.ellipse(x+4, sy+6, t.r*0.9, t.r*0.5, 0, 0, Math.PI*2);
      ctx.fillStyle = "#000";
      ctx.fill();
      ctx.globalAlpha = 1;

      // trunk
      ctx.fillStyle = "rgba(120, 80, 45, 0.65)";
      ctx.fillRect(x-2, sy + t.r*0.35, 4, t.r*0.55);

      // pine layers
      const hitGlow = Math.min(1, t.hit);
      const base = `rgba(50, 150, 140, ${0.95 - hitGlow*0.25})`;
      const hi   = `rgba(120, 230, 220, ${0.18 + hitGlow*0.25})`;

      ctx.beginPath();
      ctx.moveTo(x, sy - t.r);
      ctx.lineTo(x - t.r*0.9, sy + t.r*0.25);
      ctx.lineTo(x + t.r*0.9, sy + t.r*0.25);
      ctx.closePath();
      ctx.fillStyle = base;
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x, sy - t.r*0.55);
      ctx.lineTo(x - t.r*0.75, sy + t.r*0.45);
      ctx.lineTo(x + t.r*0.75, sy + t.r*0.45);
      ctx.closePath();
      ctx.fillStyle = "rgba(35, 120, 115, 0.95)";
      ctx.fill();

      // soft highlight
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.arc(x - t.r*0.15, sy - t.r*0.25, t.r*0.9, 0, Math.PI*2);
      ctx.fillStyle = hi;
      ctx.fill();

      // decay hit glow
      t.hit = Math.max(0, t.hit - 0.02);
    }
  }

  function drawPlayer(){
    // snowboarder as a clean little icon
    const x = player.x, y = player.y;

    // board
    ctx.save();
    ctx.translate(x, y);
    const tilt = Math.max(-0.6, Math.min(0.6, player.vx / 240));
    ctx.rotate(tilt);

    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(6, 14, 18, 6, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // board body
    const bg = ctx.createLinearGradient(-20, 0, 20, 0);
    bg.addColorStop(0, "rgba(255,255,255,0.82)");
    bg.addColorStop(1, "rgba(140,220,255,0.85)");
    ctx.fillStyle = bg;
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 2;
    roundRect(ctx, -22, 8, 44, 12, 8, true, true);

    // rider
    ctx.fillStyle = "rgba(10,20,35,0.88)";
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.arc(2, -2, 3, 0, Math.PI*2);
    ctx.fill();

    // scarf/coat accent
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-4, 4);
    ctx.lineTo(6, 6);
    ctx.stroke();

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // --- update loop ---
  let last = performance.now();

  function update(dt){
    // snow flakes drift
    for (const f of flakes){
      f.y += f.vy * dt;
      f.x += Math.sin((f.y+f.x)*0.002) * 10 * dt;
      if (f.y > H + 10){ f.y = -10; f.x = Math.random()*W; }
      if (f.x < -20) f.x = W + 20;
      if (f.x > W + 20) f.x = -20;
    }

    // timer
    elapsed = (performance.now() - timeStart) / 1000;

    // steering
    let steer = 0;
    if (keys.has("ArrowLeft")) steer -= 1;
    if (keys.has("ArrowRight")) steer += 1;

    const stabilize = keys.has("ArrowUp");
    const carve = keys.has("ArrowDown");

    // steering sensitivity scales with speed
    const steerPower = (carve ? 1.25 : 1.0) * (stabilize ? 0.85 : 1.0);
    player.vx += steer * 1300 * steerPower * dt;

    // friction / smoothing (stabilize helps)
    const damp = stabilize ? 0.90 : 0.86;
    player.vx *= Math.pow(damp, dt*60);

    // move sideways
    player.x += player.vx * dt;

    // trail constraints + “clean riding” speed reward
    const {cx, w} = sampleTrail(worldY);
    const half = w/2;

    // How centered are you? (0..1)
    const distFromCenter = Math.abs(player.x - cx);
    const centered = 1 - Math.min(1, distFromCenter / (half * 0.95));

    // speed model: base accel + bonus for being centered
    const base = 220 + level * 14;
    const max = 520 + level * 18;

    // If you ride clean, you gradually climb toward max speed
    const gain = (70 + centered * 130) * dt; // smoother, noticeable
    player.speed = Math.min(max, player.speed + gain);

    // If you drift too far from center, you lose speed a bit
    const off = Math.max(0, distFromCenter - half*0.70) / (half*0.30);
    if (off > 0){
      player.speed *= (1 - Math.min(0.20, off*0.12) * dt*3.2);
    }

    // Hard clamp within canvas for safety
    player.x = Math.max(0, Math.min(W, player.x));

    // world scroll
    worldY += player.speed * dt;

    // collisions with trees
    // (trees are fixed in world space; player is in screen space)
    const viewTop = worldY - 200;
    const viewBottom = worldY + (H - player.y) + 240;

    for (const t of trees){
      if (t.y < viewTop || t.y > viewBottom) continue;
      const sy = player.y - (t.y - worldY);

      if (circleHit(player.x, player.y, player.radius, t.x, sy, t.r*0.78)){
        // hit tree
        t.hit = 1;
        player.mistakes++;
        // meaningful slowdown (but not “instant death”)
        player.speed = Math.max(base*0.55, player.speed * 0.68);
        // bounce away
        const dir = Math.sign(player.x - t.x) || (Math.random()<0.5?-1:1);
        player.vx += dir * 420;
        break; // avoid multiple hits same frame
      }
    }

    // restart same level if too many mistakes
    if (player.mistakes >= 5){
      resetLevel(level);
      return;
    }

    // finish line reached?
    if (worldY >= finishY){
      // save best time
      const t = elapsed;
      if (!bestTimes[level] || t < bestTimes[level]) bestTimes[level] = t;

      // next level
      resetLevel(level + 1);
      // keep overlay off for flow? (we'll show but you can instantly Space)
      overlay.classList.remove('show');
      paused = false;
    }

    updateHUD();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawTrail();
    drawTrees();
    drawPlayer();

    // subtle vignette so edges feel defined (helps your brain)
    const vg = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.20, W/2, H/2, Math.max(W,H)*0.75);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);
  }

  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (!paused && !overlay.classList.contains('show')){
      update(dt);
    } else {
      // still animate background a bit while paused
      for (const f of flakes){
        f.y += (f.vy*0.35) * dt;
        if (f.y > H + 10){ f.y = -10; f.x = Math.random()*W; }
      }
      updateHUD();
    }

    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
